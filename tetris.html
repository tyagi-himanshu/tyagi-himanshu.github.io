<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tetris — Responsive (Mobile + Desktop)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    :root {
      --bg:#0b0b0c;
      --panel:#131416;
      --muted:#a1a1aa;
      --accent:#4ade80;
      --pad:16px;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(1200px 600px at 30% 20%, #111827 0%, #0b0b0c 50%, #000 100%);
      color: #fff;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      display: grid; place-items: center;
    }
    .wrap {
      width: min(100vw, 1100px);
      padding: var(--pad);
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 16px;
      align-items: start;
    }
    .stage {
      background: #000;
      border: 2px solid #2a2a2a;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.06);
      touch-action: none;
      width: 100%;
      height: auto;
      aspect-ratio: 10 / 20; /* keeps correct proportion while we internally scale for sharpness */
      display: block;
    }
    aside.panel {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.07);
      border-radius: 12px;
      padding: 14px;
      display: grid;
      gap: 12px;
    }
    h2 { margin: 4px 0 0; font-size: 18px; letter-spacing: .2px; }
    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 14px;
    }
    .stat {
      background:#0f1012;
      border:1px solid rgba(255,255,255,.08);
      border-radius: 8px;
      padding: 10px;
    }
    .stat b { display:block; font-size:12px; color:var(--muted); font-weight:500; }
    .stat span { font-size:18px; font-weight:800; }
    .buttons {
      display:grid; grid-template-columns:1fr 1fr; gap:8px;
    }
    .btn {
      appearance:none; border:1px solid rgba(255,255,255,.12);
      background:#1b1d22; color:#fff; padding:10px 12px; border-radius:8px;
      cursor:pointer; font-weight:800; letter-spacing:.2px;
    }
    .btn:hover { background:#23262c; }
    .badgelive { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; font-size:12px; border-radius:999px; background:#0f1115; border:1px solid rgba(255,255,255,.08); width:max-content; }
    .dot { width:8px; height:8px; border-radius:50%; background:#ef4444; box-shadow:0 0 10px rgba(239,68,68,.6); }
    .dot.on { background:var(--accent); box-shadow:0 0 10px rgba(74,222,128,.6); }
    .nextbox { margin-top: 4px; background:#0f1012; border:1px solid rgba(255,255,255,.06); border-radius:8px; padding:8px; display:grid; place-items:center; height:140px; }
    canvas#next { background:#000; border:1px solid #2a2a2a; border-radius:6px; width:100%; height:100%; }
    .hint { font-size:12px; color:var(--muted); border-top:1px dashed rgba(255,255,255,.08); padding-top:10px; line-height:1.35; }
    .kbd { display:inline-block; border:1px solid rgba(255,255,255,.18); border-bottom-width:2px; padding:2px 6px; border-radius:6px; background:#0f1115; font-weight:800; font-size:11px; }
    .footer { font-size:11px; color:#a1a1aa; text-align:center; }

    /* On-screen controls (mobile) */
    .controls {
      display: none;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      margin-top: 8px;
      user-select: none;
    }
    .ctrl {
      display:grid; place-items:center;
      padding: 12px 10px;
      background:#111216;
      border:1px solid rgba(255,255,255,.12);
      border-radius:10px;
      font-weight:800; font-size:14px;
      touch-action: manipulation;
    }
    .ctrl:active { transform: translateY(1px); }
    .ctrl.wide { grid-column: span 2; }

    @media (max-width: 920px) {
      .wrap { grid-template-columns: 1fr; gap: 12px; }
      aside.panel { order: -1; }
      .controls { display: grid; }
      .buttons { grid-template-columns: 1fr 1fr 1fr 1fr; }
      .hint { display:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" class="stage" aria-label="Tetris playfield"></canvas>

    <aside class="panel" aria-label="Control panel">
      <div class="badgelive"><span id="live-dot" class="dot"></span><span id="live-text">&nbsp;Stopped</span></div>

      <h2>Next</h2>
      <div class="nextbox">
        <canvas id="next" width="96" height="96"></canvas>
      </div>

      <h2>Stats</h2>
      <div class="stats">
        <div class="stat"><b>Score</b><span id="score">0</span></div>
        <div class="stat"><b>Lines</b><span id="lines">0</span></div>
        <div class="stat"><b>Level</b><span id="level">1</span></div>
        <div class="stat"><b>Speed</b><span id="speed">1000ms</span></div>
      </div>

      <h2>Controls</h2>
      <div class="buttons">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="btn">Pause</button>
        <button id="resumeBtn" class="btn">Resume</button>
        <button id="stopBtn" class="btn">Stop</button>
      </div>

      <!-- Touch controls for mobile -->
      <div class="controls" id="touchControls" aria-label="On-screen controls">
        <div class="ctrl" data-act="left">◀</div>
        <div class="ctrl" data-act="soft">▼</div>
        <div class="ctrl" data-act="right">▶</div>
        <div class="ctrl" data-act="rotate">⟳</div>
        <div class="ctrl" data-act="hard" title="Hard drop (Space)">⤓</div>

        <div class="ctrl wide" data-act="pause">⏯ Pause</div>
        <div class="ctrl wide" data-act="start">▶ Start</div>
      </div>

      <div class="hint">
        <div><span class="kbd">←</span>/<span class="kbd">A</span> left • <span class="kbd">→</span>/<span class="kbd">D</span> right</div>
        <div><span class="kbd">↑</span>/<span class="kbd">W</span> rotate • <span class="kbd">↓</span>/<span class="kbd">S</span> soft drop</div>
        <div><span class="kbd">Space</span> hard drop • <span class="kbd">P</span> pause/resume</div>
      </div>

      <div class="footer">Responsive & touch-friendly Tetris.</div>
    </aside>
  </div>

<script>
/* ======= Config & Utilities ======= */
const rows = 20, cols = 10;
let gridSize = 32; // dynamic
function getRandomInt(min, max){ min=Math.ceil(min); max=Math.floor(max); return Math.floor(Math.random()*(max-min+1))+min; }
function rotate(m){ const N=m.length-1; return m.map((row,i)=>row.map((_,j)=>m[N-j][i])); }

/* ======= DOM & Contexts ======= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nextCtx = nextCanvas.getContext('2d');

const $score = document.getElementById('score');
const $lines = document.getElementById('lines');
const $level = document.getElementById('level');
const $speed = document.getElementById('speed');
const $start = document.getElementById('startBtn');
const $pause = document.getElementById('pauseBtn');
const $resume = document.getElementById('resumeBtn');
const $stop = document.getElementById('stopBtn');
const $liveDot = document.getElementById('live-dot');
const $liveText = document.getElementById('live-text');
const $touchControls = document.getElementById('touchControls');

/* ======= Pieces ======= */
const tetrominos = {
  'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  'J': [[1,0,0],[1,1,1],[0,0,0]],
  'L': [[0,0,1],[1,1,1],[0,0,0]],
  'O': [[1,1],[1,1]],
  'S': [[0,1,1],[1,1,0],[0,0,0]],
  'Z': [[1,1,0],[0,1,1],[0,0,0]],
  'T': [[0,1,0],[1,1,1],[0,0,0]]
};
const colors = { I:'cyan', O:'yellow', T:'purple', S:'green', Z:'red', J:'blue', L:'orange' };

/* ======= Game State ======= */
let playfield = [];
let seq = [];
let active = null, queued = null;

let score = 0, lines = 0, level = 1;
let dropInterval = 1000, lastTime = 0, acc = 0;
let running = false, paused = false, over = false, rAF = null;

/* ======= Responsive Canvas + DPR ======= */
function resizeCanvases(){
  // Determine max logical width for the playfield (keep aspect 10:20)
  const stageEl = canvas;
  const rect = stageEl.getBoundingClientRect();
  // Compute grid size from current CSS width (rect.width / cols)
  let newGrid = Math.floor(rect.width / cols);
  newGrid = Math.max(16, Math.min(48, newGrid)); // clamp for usability
  gridSize = newGrid;

  const logicalW = cols * gridSize;
  const logicalH = rows * gridSize;

  // Device pixel ratio scaling for crispness
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width  = Math.floor(logicalW * dpr);
  canvas.height = Math.floor(logicalH * dpr);
  canvas.style.width  = logicalW + 'px';
  canvas.style.height = logicalH + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // Next preview: square; scale to panel's box size
  const nb = nextCanvas.parentElement.getBoundingClientRect();
  const side = Math.max(80, Math.min(180, Math.floor(Math.min(nb.width, nb.height) - 14)));
  const ndpr = dpr;
  nextCanvas.width  = Math.floor(side * ndpr);
  nextCanvas.height = Math.floor(side * ndpr);
  nextCtx.setTransform(ndpr,0,0,ndpr,0,0);
  nextCanvas.style.width = side + 'px';
  nextCanvas.style.height = side + 'px';

  drawAll();
}

/* ======= Init/Reset ======= */
function resetField(){
  playfield = [];
  for (let r = -2; r < rows; r++){
    playfield[r] = [];
    for (let c=0; c<cols; c++) playfield[r][c]=0;
  }
}
function bag(){
  const b=['I','J','L','O','S','T','Z'];
  while(b.length){ seq.push(b.splice(getRandomInt(0,b.length-1),1)[0]); }
}
function nextPiece(){
  if (!seq.length) bag();
  const name = seq.pop();
  const matrix = tetrominos[name];
  const col = Math.floor(cols/2 - Math.ceil(matrix[0].length/2));
  const row = (name==='I') ? -1 : -2;
  return { name, matrix, row, col };
}
function setNewActive(){
  active = queued ?? nextPiece();
  queued = nextPiece();
  drawNext();
}

/* ======= Mechanics ======= */
function isValid(matrix, row, col){
  for (let r=0; r<matrix.length; r++){
    for (let c=0; c<matrix[r].length; c++){
      if (matrix[r][c]){
        const rr=row+r, cc=col+c;
        if (cc < 0 || cc >= cols || rr >= rows) return false;
        if (rr >= 0 && playfield[rr][cc]) return false;
      }
    }
  }
  return true;
}
function lock(){
  for (let r=0;r<active.matrix.length;r++){
    for (let c=0;c<active.matrix[r].length;c++){
      if (active.matrix[r][c]){
        if (active.row + r < 0) return gameOver();
        playfield[active.row+r][active.col+c] = active.name;
      }
    }
  }
  // clear lines
  let cleared=0;
  for (let r=rows-1; r>=0; ){
    if (playfield[r].every(v=>!!v)){
      for (let rr=r; rr>=0; rr--){
        for (let cc=0; cc<cols; cc++){
          playfield[rr][cc] = playfield[rr-1]?.[cc] || 0;
        }
      }
      cleared++;
    } else r--;
  }
  if (cleared){
    const table=[0,100,300,500,800];
    score += table[cleared] * level;
    lines += cleared;
    const newLvl = Math.min(20, Math.floor(lines/10)+1);
    if (newLvl !== level){
      level = newLvl;
      dropInterval = Math.max(70, Math.floor(1000 * Math.pow(0.85, level-1)));
    }
    updateUI();
  }
  setNewActive();
}
function move(dx){
  if (!active) return;
  const col = active.col + dx;
  if (isValid(active.matrix, active.row, col)) active.col = col;
}
function rotateActive(){
  if (!active) return;
  const m = rotate(active.matrix);
  if (isValid(m, active.row, active.col)) active.matrix = m;
}
function softDrop(){
  if (!active) return;
  const r = active.row + 1;
  if (isValid(active.matrix, r, active.col)) active.row = r;
  else lock();
}
function hardDrop(){
  if (!active) return;
  while (isValid(active.matrix, active.row+1, active.col)) active.row++;
  lock();
}

/* ======= Rendering ======= */
function drawField(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // settled
  for (let r=0; r<rows; r++){
    for (let c=0; c<cols; c++){
      const cell = playfield[r][c];
      if (cell){
        ctx.fillStyle = colors[cell];
        ctx.fillRect(c*gridSize, r*gridSize, gridSize-1, gridSize-1);
      }
    }
  }
  // active
  if (active){
    ctx.fillStyle = colors[active.name];
    for (let r=0; r<active.matrix.length; r++){
      for (let c=0; c<active.matrix[r].length; c++){
        if (active.matrix[r][c]){
          const x=(active.col+c)*gridSize, y=(active.row+r)*gridSize;
          ctx.fillRect(x, y, gridSize-1, gridSize-1);
        }
      }
    }
  }
}
function drawNext(){
  nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  if (!queued) return;
  const m = queued.matrix;
  // cell size based on preview canvas size
  const side = parseInt(nextCanvas.style.width || nextCanvas.width, 10);
  const base = Math.floor((side || 120) / 5); // enough room
  const cell = Math.max(12, Math.min(28, base));
  const w = m[0].length * cell, h = m.length * cell;
  const ox = Math.floor(( (side||120) - w)/2);
  const oy = Math.floor(( (side||120) - h)/2);
  nextCtx.fillStyle = colors[queued.name];
  for (let r=0; r<m.length; r++){
    for (let c=0; c<m[r].length; c++){
      if (m[r][c]){
        nextCtx.fillRect(ox + c*cell, oy + r*cell, cell-2, cell-2);
      }
    }
  }
}
function drawAll(){ drawField(); drawNext(); }

/* ======= Loop ======= */
function loop(ts){
  if (!running) return;
  rAF = requestAnimationFrame(loop);
  if (paused) return;
  if (!lastTime) lastTime = ts;
  const dt = ts - lastTime; lastTime = ts;
  acc += dt;
  if (acc >= dropInterval){
    acc -= dropInterval;
    if (active){
      if (isValid(active.matrix, active.row+1, active.col)) active.row++;
      else lock();
    }
  }
  drawField();
}

/* ======= UI ======= */
function updateUI(){
  $score.textContent = score;
  $lines.textContent = lines;
  $level.textContent = level;
  $speed.textContent = dropInterval + 'ms';
  $liveDot.classList.toggle('on', running && !paused && !over);
  $liveText.textContent = over ? ' Game Over' : running ? (paused ? ' Paused' : ' Running') : ' Stopped';
}
function gameOver(){
  over = true; running = false; paused = false;
  cancelAnimationFrame(rAF);
  ctx.fillStyle='rgba(0,0,0,.75)';
  ctx.fillRect(0, (rows*gridSize)/2 - 40, cols*gridSize, 80);
  ctx.fillStyle='#fff';
  ctx.font='32px monospace';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('GAME OVER', (cols*gridSize)/2, (rows*gridSize)/2);
  updateUI();
}

/* ======= Controls: Keyboard ======= */
document.addEventListener('keydown', (e)=>{
  if (over) return;
  const code = e.code;
  if (code==='KeyP'){ if (running){ paused = !paused; updateUI(); } return; }
  if (!running || paused) return;

  if (code==='ArrowLeft' || code==='KeyA'){ e.preventDefault(); move(-1); }
  else if (code==='ArrowRight' || code==='KeyD'){ e.preventDefault(); move(1); }
  else if (code==='ArrowUp' || code==='KeyW'){ e.preventDefault(); rotateActive(); }
  else if (code==='ArrowDown' || code==='KeyS'){ e.preventDefault(); softDrop(); }
  else if (code==='Space'){ e.preventDefault(); hardDrop(); }

  drawField();
});

/* ======= Controls: Touch (buttons) ======= */
function bindTouchControls(){
  const press = (el, handler)=>{
    let holdId=null, repeatDelay=120; // hold to repeat for left/right/down
    const start=(ev)=>{ ev.preventDefault(); handler('start');
      // start repeating for move/soft
      if (['left','right','soft'].includes(el.dataset.act)){
        holdId = setInterval(()=>handler('hold'), repeatDelay);
      }
    };
    const end=()=>{ handler('end'); if (holdId){ clearInterval(holdId); holdId=null; } };
    el.addEventListener('touchstart', start, {passive:false});
    el.addEventListener('mousedown', start);
    ['touchend','touchcancel','mouseup','mouseleave'].forEach(evt=> el.addEventListener(evt, end));
  };

  const map = {
    left: ()=> move(-1),
    right: ()=> move(1),
    rotate: ()=> rotateActive(),
    soft: ()=> softDrop(),
    hard: ()=> hardDrop(),
    pause: ()=> { if (!running) return; paused=!paused; updateUI(); },
    start: ()=> {
      if (running && !over) return;
      startGame();
    }
  };

  $touchControls.querySelectorAll('.ctrl').forEach(el=>{
    bindTouchControls(el, (phase)=>{
      const act = el.dataset.act;
      if (!act) return;
      if (act==='pause' || act==='start'){
        if (phase==='start'){ map[act](); }
        return;
      }
      if (!running || paused || over) return;
      if (phase==='start' || phase==='hold'){ map[act](); drawField(); }
    });
  });
}

/* ======= Buttons ======= */
function startGame(){
  cancelAnimationFrame(rAF);
  score=0; lines=0; level=1; dropInterval=1000; lastTime=0; acc=0; over=false; paused=false; running=true;
  seq=[]; resetField();
  active = nextPiece(); queued = nextPiece(); drawNext(); updateUI(); drawAll();
  rAF = requestAnimationFrame(loop);
}
$start.addEventListener('click', startGame);
$pause.addEventListener('click', ()=>{ if (!running || over) return; paused=true; updateUI(); });
$resume.addEventListener('click', ()=>{ if (!running || over) return; paused=false; updateUI(); });
$stop.addEventListener('click', ()=>{ if (!running) return; running=false; paused=false; updateUI(); cancelAnimationFrame(rAF); });

/* ======= Boot ======= */
resetField(); updateUI(); drawAll();
bindTouchControls();
window.addEventListener('resize', resizeCanvases);
window.addEventListener('orientationchange', ()=> setTimeout(resizeCanvases, 200));
requestAnimationFrame(()=>resizeCanvases());
</script>
</body>
</html>
